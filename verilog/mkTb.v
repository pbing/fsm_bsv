//
// Generated by Bluespec Compiler, version 2021.07 (build 4cac6eb)
//
// On Sun Sep 26 19:34:11 CEST 2021
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTb(CLK,
	    RST_N);
  input  CLK;
  input  RST_N;

  // register cycles
  reg [31 : 0] cycles;
  wire [31 : 0] cycles$D_IN;
  wire cycles$EN;

  // register ds
  reg ds;
  wire ds$D_IN, ds$EN;

  // register go
  reg go;
  wire go$D_IN, go$EN;

  // ports of submodule fsm1c
  wire fsm1c$ds, fsm1c$rd, fsm1c$start_go, fsm1c$start_ws;

  // ports of submodule fsm1r
  wire fsm1r$ds, fsm1r$rd, fsm1r$start_go, fsm1r$start_ws;

  // declarations used by system tasks
  // synopsys translate_off
  reg [63 : 0] v__h842;
  reg [63 : 0] v__h903;
  // synopsys translate_on

  // remaining internal signals
  wire NOT_fsm1r_ds__0_EQ_fsm1c_ds__1_2___d23,
       NOT_fsm1r_rd__5_EQ_fsm1c_rd__6_7___d18;

  // submodule fsm1c
  mkFsm1_comb fsm1c(.CLK(CLK),
		    .RST_N(RST_N),
		    .start_go(fsm1c$start_go),
		    .start_ws(fsm1c$start_ws),
		    .rd(fsm1c$rd),
		    .ds(fsm1c$ds));

  // submodule fsm1r
  mkFsm1 fsm1r(.CLK(CLK),
	       .RST_N(RST_N),
	       .start_go(fsm1r$start_go),
	       .start_ws(fsm1r$start_ws),
	       .rd(fsm1r$rd),
	       .ds(fsm1r$ds));

  // register cycles
  assign cycles$D_IN = cycles + 32'd1 ;
  assign cycles$EN = 1'd1 ;

  // register ds
  assign ds$D_IN = cycles == 32'd3 ;
  assign ds$EN =
	     cycles == 32'd0 || cycles == 32'd1 || cycles == 32'd2 ||
	     cycles == 32'd3 ||
	     cycles == 32'd4 ;

  // register go
  assign go$D_IN = cycles == 32'd1 ;
  assign go$EN =
	     cycles == 32'd0 || cycles == 32'd1 || cycles == 32'd2 ||
	     cycles == 32'd3 ||
	     cycles == 32'd4 ;

  // submodule fsm1c
  assign fsm1c$start_go = go ;
  assign fsm1c$start_ws = ds ;

  // submodule fsm1r
  assign fsm1r$start_go = go ;
  assign fsm1r$start_ws = ds ;

  // remaining internal signals
  assign NOT_fsm1r_ds__0_EQ_fsm1c_ds__1_2___d23 = fsm1r$ds != fsm1c$ds ;
  assign NOT_fsm1r_rd__5_EQ_fsm1c_rd__6_7___d18 = fsm1r$rd != fsm1c$rd ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        cycles <= `BSV_ASSIGNMENT_DELAY 32'd0;
	ds <= `BSV_ASSIGNMENT_DELAY 1'd0;
	go <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (cycles$EN) cycles <= `BSV_ASSIGNMENT_DELAY cycles$D_IN;
	if (ds$EN) ds <= `BSV_ASSIGNMENT_DELAY ds$D_IN;
	if (go$EN) go <= `BSV_ASSIGNMENT_DELAY go$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    cycles = 32'hAAAAAAAA;
    ds = 1'h0;
    go = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (NOT_fsm1r_rd__5_EQ_fsm1c_rd__6_7___d18)
	begin
	  v__h842 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (NOT_fsm1r_rd__5_EQ_fsm1c_rd__6_7___d18)
	$display("%t fsm1r.rd=%b fsm1c.rd=%b", v__h842, fsm1r$rd, fsm1c$rd);
    if (RST_N != `BSV_RESET_VALUE)
      if (NOT_fsm1r_ds__0_EQ_fsm1c_ds__1_2___d23)
	begin
	  v__h903 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (NOT_fsm1r_ds__0_EQ_fsm1c_ds__1_2___d23)
	$display("%t fsm1r.ds=%b fsm1c.ds=%b", v__h903, fsm1r$ds, fsm1c$ds);
    if (RST_N != `BSV_RESET_VALUE) if (cycles == 32'd8) $finish(32'd1);
  end
  // synopsys translate_on
endmodule  // mkTb

